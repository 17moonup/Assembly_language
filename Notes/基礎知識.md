# 匯編語言

#### :question:爲什麽要學習匯編

匯編語言是一門最貼近硬件實體的計算機語言,學習它能讓你理解或者説可以幫助你理解許多高級語言和操作系統課程以及數據結構中你可能感到困惑或者你忽略掉的重要問題,是學習計算機重要的基石。

不論你想要獲得充分的底層編程（編程的平臺是硬件而不是操作系統，後面會體驗一個裸機的環境下，也就是沒有操作系統的硬件上直接進行編程）體驗還是深刻理解機器運行程序的原理，學習匯編在我看來都是必要的。

“完全抛棄BIOS和DOS中斷，直接訪問硬件，發揮匯編語言的長處才是我們的目的”——《x86匯編語言從實模式到保護模式》

"利用硬件系統的編程結構和指令集有效靈活的控制系統進行工作"——《匯編語言》

### Hardware-based

- 瞭解8086的内存訪問方式
- 瞭解分段機制對程序重定位的好處
- 理解INTEL8086處理器内存分段的本質,

在討論進入正題之前，先討論一下匯編語言的產生。

在討論匯編語言的產生之前，先看一下[機器語言:smiling_imp:](https://zh.wikipedia.org/zh-hant/%E6%9C%BA%E5%99%A8%E8%AF%AD%E8%A8%80#:~:text=%E6%A9%9F%E5%99%A8%E8%AA%9E%E8%A8%80%20%EF%BC%88%20machine%20language%20%EF%BC%89%E6%98%AF%E4%B8%80%E7%A8%AE%20%E6%8C%87%E4%BB%A4%E9%9B%86%20%E7%9A%84%E9%AB%94%E7%B3%BB%E3%80%82%20%E9%80%99%E7%A8%AE%E6%8C%87%E4%BB%A4%E9%9B%86%E7%A8%B1%E7%82%BA,%EF%BC%88%20Native%20Code%20%EF%BC%89%EF%BC%8C%E9%80%99%E5%80%8B%E5%90%8D%E8%A9%9E%E6%AF%94%E8%BC%83%E5%BC%B7%E8%AA%BF%E6%9F%90%E7%A8%AE%20%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80%20%E6%88%96%20%E5%87%BD%E5%BC%8F%E5%BA%AB%20%E8%88%87%E5%9F%B7%E8%A1%8C%E5%B9%B3%E5%8F%B0%E7%9B%B8%E9%97%9C%E7%9A%84%E9%83%A8%E4%BB%BD%E3%80%82)

機器語言是比匯編語言還更Hardware的語言，如果沒有學習過計算機組成原理這門課建議先去看看[crash course computer science](https://www.bilibili.com/video/BV1EW411u7th?spm_id_from=333.337.search-card.all.click)這門課，涉及了數據是如何存儲在内存中的，内存又是如何保存數據的，以及一些加法器，還講解了計算機的歷史。

——————————————————————————————————————————————————

匯編語言和機器語言的差別在於指令的表示方法上，匯編指令是機器指令的便於人記憶的書寫形式。

#### 匯編語言的組成(這裏首先討論的是基於16位的INTEL8086處理器的匯編)

![](https://tse2-mm.cn.bing.net/th/id/OIP-C.qNrKEibuyMWcKYHPoo6uXAHaE8?pid=ImgDet&rs=1)

有20根地址綫，可以尋址2^20 = 1Mb 内存。32位的x86處理器擁有32條地址綫，可以尋址4GB，但32bit和16bit的差距絕不是增加了地址綫和數據綫這麽簡單，還包括了高速緩存、多處理器管理、分支預測、虛擬化、溫度以及電源管理等。

#### 匯編語言的組成

Need a Picture

- 匯編指令：機器碼的助記符，有對應的機器碼，最終會由CPU執行
- 僞指令：沒有對應的機器碼，最終由編譯器執行
- 其他符號：如“+，-,*,/"等，也由編譯器執行

指令（1~15 byte）和指令集：用某些數來指示處理器所進行的操作；一個處理器能識別的指令的集合叫做指令集。

- 操作碼隱含了如何執行該指令的信息（如mov，add，dec等是做什麽的以及如何去做的信息）
  - 操作數指出指令執行的操作所需要數據的來源。
    - 立即操作數：指令要操作的數據以常量的形式出現在指令中，也成爲立即數。
    - 寄存器操作數：指令要操作的數據存放在CPU的寄存器裏
    - 記憶體操作數：指令要操作的數據存放在内存的某些單元内，指令中給出内存單元的物理地址（以段地址+偏移地址的形式）

#### 指令和數據

指令和數據都在存儲器中存放，那既然指令和數據都是01組成的機器碼，**計算機又是如何區分二者**，**以及如何讀取指令和寫入指令的呢**？

這裏需要辯證的看待二者的關係，但從存儲形式上來看，它們都是一些高低電平組合，沒有區別，可以是數據也可以是程序：

​					如：1000100111011000   :arrow_right: 89D8H （數據）

​							1000100111011000   :arrow_right: mov  ax,bx （指令）

就像在棋盤上的圍棋，在沒下之前都一樣，對弈時產生了不同的意義。

但是，你無法保證所有的數據都有對應的程序形式，每種處理器在設計的時候都有幾十到幾百條程序指令,而處理器是自動地按照順序進行取指令並加以執行的，加入你在指令集中混雜了非指令的數據將會導致處理器無法正常工作（Hack :question: )，因此實際上指令和數據是分開存放的，分別處於指令區和數據區，並要告訴處理器要執行的指令處於内存的位置。

#### 内存儲器(Storage/Memory)和讀寫(read&write)

存儲器被劃分爲若干個存儲單元,按順序從0開始編號,編號就是地址。

例圖為一個128字節的存儲器，此時假設cpu要對内存進行操作（write/read)

- 地址信息(處理器需要給出一個要讀或寫的地址）
- 控制信息（指明是讀還是寫，以及器件的選擇）
- 數據信息（給出要讀或寫的數據）

Apparently，cpu和内存直接交流了，一定有電子在你寫匯編程序時在你手底下運動了，那麽是怎麽傳輸這些信息的呢？

電子肯定通過導綫傳輸:electric_plug:根據功能不同在邏輯上分爲

- 地址總綫

  地址總綫用來傳輸要讀或者要寫的地址信息，顯然你能進行操作的範圍（尋址範圍）即縂綫上能傳送的不同信息數，對8086來説，之前提到過它有20根地址綫，即2^20=1M

- 控製總線

  控制總綫寬度決定了cpu對外部器件的控制能力，有多少跟總綫就意味著cpu提供多少種對外部器件的控制。

- 數據總綫

  cpu與内存或其他器件之間的數據傳輸,其寬度也就是根數決定了cpu和外界的數據傳輸速度,

  8086有16根數據綫一次可以傳送16位=2bytes的數據,8088只有8根,所以儅傳輸2B的數據時,8088要分兩次傳輸。在不考慮任何其他影響因素下，單從這一點模型，讀取一個2

  M的數據需要1048576次，雖然電子的速度非常快，但正常情況下無法更快，顯然把數據綫拓寬是發展趨勢，也是高性能做法。然而，隨著要存的數據越來越多，圖片，視頻，音訊。内存也越來越大，如果能有效讀寫一些經常使用的數據是非常能提升效率的行爲。cache就出現了，這篇文章講了前端總綫（Front Side Bus）、cacheline和内存的關係，以及并發、多核單核的讀取。

#### 各類存儲器芯片

RAM和ROM在章首crash course Computer Science中介紹過

#### 寄存器

位於cpu内部，可以通過改變其中内容對cpu控制。

對8086來説，其内部有8個16位的寄存器：AX、BX、CX、DX、SI、DI、BP、SP、IP、CS、SS、DS、ES、PSW。其中前4個可以拆成兩個8位寄存器使用，且互不影響。

#### 段寄存器

- CS（code segment）

  IP是指令指針寄存器，8086中，cs:ip指向的内容是cpu執行的指令地址

- DS（data segement）

- SS（stack segment）

- ES（extra segment）

#### 8086的内存訪問方式

數據段、代碼段都是我們邏輯上分出的段，實際上内存根本不認識這些段，分段的本質是我們如何看待這些數據。可實際上程序在内存的加載位置是非常隨機的，哪裏空閑就往那裏加載，如果我們使用絕對的物理地址是非常容易出差錯的，段的位置其實并不重要，我們可以隨意通過段地址加偏移地址進行訪問，重要的是分段機制解決了程序的重定位問題，也就是絕對物理地址導致的問題。

給個例子理解一下：假設你寫了一個程序

```assembly
mov ax,1000 ;將1000（D）送進ax寄存器中
mov bx,2000
add ax,bx   ;將ax中的值和bx相加送入ax中
```

 然後標記了1000h為這段程序的地址，然後編譯成.exe文件發給了小白鼠，小白鼠的1000h処並不是你的程序，你的.exe已經被他的機器加載到空閑區去了，所以就失敗了。分段的本質是，CS（code segment）和DS（data segment) 分開，這樣小白鼠再運行的時侯cpu會去cs的段裏那mov指令和add指令，去ds拿1000，2000。

### Summary：

- 運算器進行信息處理；
- 寄存器進行信息存儲；
- 控制器控制各種器件進行工作；
- 内部總綫連接各種器件，在它們之間進行數據的傳送；
